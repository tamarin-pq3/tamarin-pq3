theory iMessagePQ3
begin

/**

Color semantics:

- Yellow (#FDFD96)      Key setup/distribution
- Red (#FF6961)         Adversary activity
- Light blue (#B4D9EF)  Public key ratchet / session start
- Dark blue (#6495ED)   Non-deterministic branching before public key ratchet
- Orange (#FF7F50)      Symmetric ratchet

 */

heuristic: O "./oracle.py"

restriction Eq:
  "All a b #t. Eq(a, b) @ #t ==> a = b"

restriction Neq:
  "All a b #t. Neq(a, b) @ #t ==> not (a = b)"

restriction OnlyOnce:
  "All t #a #b. OnlyOnce(t) @ #a & OnlyOnce(t) @ #b ==> #a = #b"

builtins: signing, symmetric-encryption, diffie-hellman, natural-numbers

// KDFs and hash functions
functions:  hkdf/2,   // intended use: hkdf(entropy, <info, salt>) or hkdf(entropy, salt) or hkdf(entropy, info)
            suffix/1, // intended use: extract messageKey from chainKey
            prefix/1,
            concat/2,
            h/1

equations: concat(prefix(x), suffix(x)) = x

// KEM
functions: pqpk/1, encap/2, decap/2
equations: decap(encap(k, pqpk(sk)), sk) = k

// Handling of branches
functions: default/2, Just/1, None/0, unjust/1
equations: default(Just(v), t) = v, default(None, v) = v, unjust(Just(t)) = t

// PQ Attacker
rule PQAttackerStart[color=#FF6961]:
  [] --[ PQAttack(), SomeCompromise() ]-> [ !PQAttacker() ]

rule PQAttacker[color=#FF6961]:
  [ !PQAttacker(), !NonPQSecKey(k) ] --> [ Out(k) ]

restriction PQAttacker:
  "All #compr #t. PQAttack() @ #compr & PrePQAttack() @ #t ==> #t < #compr"

// Key Registration and Querying

// A user generates keys and uploads them to the IDS.
rule UserKeyGen[color=#FDFD96]:
  let idPk = pk(~idKey)
      ecdhPk = 'g'^~preKey
      kemPk = pqpk(~kemPreKey)
      sig = sign(<'nf_reg', kemPk, ecdhPk>, ~idKey)
  in
  [ Fr(~idKey), Fr(~preKey), Fr(~kemPreKey) ]
  --[ PrePQAttack()
    , OnlyOnce(<'setup', $A>)
    , ECDHPreKeyGen($A, 'g'^~preKey)
    , KemPreKeyGen($A, pqpk(~kemPreKey)) ]->
  [ !IdentityKey($A, ~idKey)
  , !ECDHPreKey($A, ~preKey)
  , !KemPreKey($A, ~kemPreKey)
  , Out(idPk), Out(ecdhPk), Out(kemPk), Out(sig)
  , !IDSIdentityData($A, idPk)
  , !IDSClientData($A, ecdhPk, kemPk, sig)
  , !NonPQSecKey(~idKey)
  , !NonPQSecKey(~preKey) ]

rule IdentityKeyLeak[color=#FF6961]:
  [ !IdentityKey($A, ~idKey) ]
  --[ SomeCompromise()
    , CompromisedIdentityKey($A) ]->
  [ Out(~idKey) ]

rule ECDHPreKeyLeak[color=#FF6961]:
  [ !ECDHPreKey($A, ~preKey) ]
  --[ SomeCompromise()
    , CompromisedECDHPreKey($A, 'g'^~preKey) ]->
  [ Out(~preKey) ]

rule ECDHKeyLeak[color=#FF6961]:
  [ !ECDHKey(~id, $A, ~ecdhSk) ]
  --[ SomeCompromise()
    , CompromisedECDHKey(~id, $A, 'g'^~ecdhSk) ]->
  [ Out(~ecdhSk) ]

rule KemPreKeyLeak[color=#FF6961]:
  [ !KemPreKey($A, ~sk) ]
  --[ SomeCompromise()
    , CompromisedKemPreKey($A, pqpk(~sk)) ]->
  [ Out(~sk) ]

rule KemKeyLeak[color=#FF6961]:
  [ !KemKey($A, ~kemKey) ]
  --[ SomeCompromise()
    , CompromisedKemKey($A, pqpk(~kemKey)) ]->
  [ Out(~kemKey) ]

rule RootKeyLeak[color=#FF6961]:
  [ !RootKey(~id, i, $A, kemSS, rk) ]
  --[ SomeCompromise()
    , CompromisedRootKey($A, kemSS, rk) ]->
    [ Out(rk) ]

rule ChainKeyLeak[color=#FF6961]:
  [ !ChainKey(~id, i, $A, ck) ]
  --[ SomeCompromise()
    , CompromisedChainKey($A, ck) ]->
  [ Out(ck) ]

// Provable (auto)
lemma ChainKeySources[sources]:
" All p t #x.
        CompromisedChainKey(p, t) @ #x
    ==> ( (Ex t1 t2. t = hkdf(t1, t2) & t2 = 'chain_key')
        | (Ex t1 t2 t3. t = suffix(hkdf(hkdf(t1, t2), t3))))"

rule MessageKeyLeak[color=#FF6961]:
  [ !MessageKey(~id, i, $A, mk) ]
  --[ SomeCompromise()
    , CompromisedMessageKey($A, mk) ]->
  [ Out(mk) ]

// TODO: I could non-deterministically model that the signature is invalid. The
// spec doesn't say, though, what should happen if this were the case.
rule QueryIDS[color=#FDFD96]:
  [ !IDSIdentityData($A, idPk)
  , !IDSClientData($A, prePk, kemPrePk, preKeySig) ]
  --[ PrePQAttack()
    , Eq(verify(preKeySig, <'nf_reg', kemPrePk, prePk>, idPk), true) ]->
  [ IDSQuery($A, idPk, prePk, kemPrePk, preKeySig) ]

/* ---- GENERAL DOCUMENTATION ---- */

// First a comment on how the session state is modelled. The specification
// defines that a paricipant has one "outgoing chain", and multiple "incoming
// chains". Currently, we model only one chain per participant in the symmetric
// Session fact. I next document what each argument encodes:
/**
    Session(
      // Session ID per participant.
      ~id,
      // Message index; index of the message that was sent/received last.
      %i,
      // Role that participant $Me is currently operating in: 'S' for sender,
      // 'R' for receiver.
      role,
      // The participant that has this session state.
      $Me,
      // The last generated ECDH private key of $Me. Will be initialized with
      // the pre-key from the IDS data (when initially receiver) or a fresh
      // value (when initially sender), and updated on each public key ratchet.
      // ratchet.
      ~ecdhSk,
      // The KEM secret key of $Me.
      ~kemSk,
      // The participant that $Me has a session with.
      $Them,
      // $Them's ID public key. Will be retrieved from the IDS data facts.
      theirIdPk,
      // $Them's last ECDH public key, analgous to ~ecdhSk.
      theirEcdhPk,
      // $Them's last KEM public key (of type maybe)
      maybeTheirKemPk,
      // $Them's new KEM public key. $Them might have included this key
      // when they last performed the public key ratchet becoming a sender. We
      // need to keep this key until $Me becomes sender again and will include a
      // fresh KEM shared secret.
      maybeTheirNewKemPk,
      // The current KEM SS
      kemSS,
      // The KEM public key that was used to encapsulate the current KEM SS
      encapPk,
      // The root key that will be used in the next public key ratchet.
      rootKey,
      // The symmetric ratchet's chain key.
      chainKey
    )
 */

// Model of "iMessage PQ3 Start / Session Start as a Sender"
rule SessionStartAsASender[color=#B4D9EF]:
  let dst             = <$Me, pk(~idKey), $Them, theirIdPk>
      ecdhSS          = theirEcdhPk^~ecdhSk
      kemPublicKey    = pqpk(~kemSk)
      kemEncap        = encap(~kemSS, theirKemPk)
      rkCK            = hkdf(hkdf(hkdf(ecdhSS, '0'), ~kemSS), dst)
      chainKey        = suffix(rkCK)
      preKeyHash      = h(<theirEcdhPk, theirKemPk, preKeySig>)
      msgKey          = hkdf(chainKey, 'msg_key')
      msgKeyIndicator = hkdf(msgKey, 'msg_key_ind')
      nextChainKey    = hkdf(chainKey, 'chain_key')
      ciphertext      = senc(~msg, msgKey)
      body            = <'msg_sig', ciphertext, msgKeyIndicator, 'g'^~ecdhSk, %1, dst, None, Just(kemEncap), Just(preKeyHash)>
      signature       = sign(body, ~idKey)
  in
  [ Fr(~id)
  , !IdentityKey($Me, ~idKey)
  , !KemPreKey($Me, ~kemSk)
  , IDSQuery($Them, theirIdPk, theirEcdhPk, theirKemPk, preKeySig)
  , Fr(~msg), Fr(~ecdhSk), Fr(~kemSS) ]
  --[ PrePQAttack()
    , SessionInfo(~id, %1, $Me, $Them)
    , IdentityKeyQueried(~id, $Them, theirIdPk)
    , SessionStart(theirIdPk)
    , PublicKeyRatchet(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, pqpk(~kemSk), Just(theirKemPk), None, ~kemSS, theirKemPk, prefix(rkCK))
    , PKRatchet()
    , ToSender()
    , MessageSent(~id, %1, $Me, $Them, ~msg)
    , SessionSecrets('g'^~ecdhSk, theirEcdhPk, ~kemSS, theirKemPk, chainKey, msgKey)
    , KeysUsed(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, pqpk(~kemSk), Just(theirKemPk), None, ~kemSS, theirKemPk, prefix(rkCK), chainKey, msgKey)
    , ECDHKeyGen(~id, $Me, $Them, 'g'^~ecdhSk)
    , NewKemSS(~id, $Me, $Them, ~kemSS, theirKemPk)
    , NewKemPublicKey(~id, $Me, $Them, Just(theirKemPk)) ]->
  [ Out(<ciphertext, signature, 'g'^~ecdhSk, %1, msgKeyIndicator, None, Just(kemEncap), Just(preKeyHash)>)
  , Session(~id, %1, 'S', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, theirEcdhPk, Just(theirKemPk), None /* maybeTheirNewKemPk */, ~kemSS, theirKemPk, prefix(rkCK), nextChainKey)
  , Out('g'^~ecdhSk)
  , !NonPQSecKey(~ecdhSk)
  , !RootKey(~id, %1, $Me, ~kemSS, prefix(rkCK))
  , !ChainKey(~id, %1, $Me, chainKey)
  , !MessageKey(~id, %1, $Me, msgKey)
  , !ECDHKey(~id, $Me, ~ecdhSk) ]

// Model of "iMessage PQ3 Symmetric Ratcheting" (sender view)
rule SendSymmetricRatchet[color=#FF7F50]:
  let dst = <$Me, pk(~idKey), $Them, theirIdPk>
      msgKey = hkdf(chainKey, 'msg_key')
      msgKeyIndicator = hkdf(msgKey, 'msg_key_ind')
      nextChainKey = hkdf(chainKey, 'chain_key')
      ciphertext = senc(~msg, msgKey)
      body = <'msg_sig', ciphertext, msgKeyIndicator, 'g'^~ecdhSk, %i %+ %1, dst, None /* maybeMyNewKemPk */, None /* maybeKemEncap */, None /* maybePreKeyHash */>
      signature = sign(body, ~idKey)
  in
  [ !IdentityKey($Me, ~idKey)
  , Fr(~msg)
  , Session(~id, %i, 'S', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, theirEcdhPk, maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, rootKey, chainKey) ]
  --[ PrePQAttack()
    , SessionInfo(~id, %i %+ %1, $Me, $Them)
    , MessageSent(~id, %i %+ %1, $Me, $Them, ~msg)
    , SessionSecrets('g'^~ecdhSk, theirEcdhPk, kemSS, encapPk, chainKey, msgKey)
    , SymmetricRatchet()
    , KeysUsed(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, theirEcdhPk^~ecdhSk, pqpk(~kemSk), maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, rootKey, chainKey, msgKey) ]->
  [ Out(<ciphertext, signature, 'g'^~ecdhSk, %i %+ %1, msgKeyIndicator, None /* maybeMyNewKemPk */, None /* maybeKemEncap */, None /* maybePreKeyHash */>)
  , Session(~id, %i %+ %1, 'S', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, theirEcdhPk, maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, rootKey, nextChainKey)
  , !ChainKey(~id, %i %+ %1, $Me, chainKey)
  , !MessageKey(~id, %i %+ %1, $Me, msgKey) ]

// Model of "iMessage PQ3 Start / Session Start as a Receiver"
rule ReceiverStart[color=#B4D9EF]:
  let dst           = <$Them, theirIdPk, $Me, pk(~idKey)>
      kemSS         = decap(kemEncap, ~kemSk)
      ecdhSS        = theirEcdhPk^~ecdhSk
      rkCK          = hkdf(hkdf(hkdf(ecdhSS, '0'), kemSS), dst)
      chainKey      = suffix(rkCK)
      msgKey        = hkdf(chainKey, 'msg_key')
      nextChainKey  = hkdf(chainKey, 'chain_key')
      // We pattern match the new KEM PK to None because the spec does not
      // foresee including a new KEM key in the first message.
      body          = <'msg_sig', ciphertext, msgKeyIndicator, theirEcdhPk, %1, dst, None /* maybeTheirNewKemPk */, Just(kemEncap), Just(preKeyHash)>
  in
  [ Fr(~id)
  , In(<ciphertext, signature, theirEcdhPk, %1, msgKeyIndicator, None, Just(kemEncap), Just(preKeyHash)>)
  , !IdentityKey($Me, ~idKey)
  , !ECDHPreKey($Me, ~ecdhSk)
  , !KemPreKey($Me, ~kemSk)
  , IDSQuery($Them, theirIdPk, sprePk, skemPrePk, preKeySig) ]
  --[ PrePQAttack()
    , Neq(theirEcdhPk, DH_neutral)
    , Neq(theirEcdhPk, 'g')
    , Neq(kemSS, '0')
    , Eq(verify(signature, body, theirIdPk), true)
    , Eq(preKeyHash, h(<'g'^~ecdhSk, pqpk(~kemSk), sign(<'nf_reg', pqpk(~kemSk), 'g'^~ecdhSk>, ~idKey)>))
    , Eq(msgKeyIndicator, hkdf(msgKey, 'msg_key_ind'))
    , SessionInfo(~id, %1, $Me, $Them)
    , IdentityKeyQueried(~id, $Them, theirIdPk)
    , SessionStart(theirIdPk)
    , PublicKeyRatchet(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, pqpk(~kemSk), None, None, kemSS, pqpk(~kemSk), prefix(rkCK))
    , PKRatchet()
    , ToReceiver()
    , MessageReceived(~id, %1, $Them, $Me, sdec(ciphertext, msgKey))
    , SessionSecrets('g'^~ecdhSk, theirEcdhPk, kemSS, pqpk(~kemSk), chainKey, msgKey)
    , DecapKemSS(~id, $Me, $Them, kemSS, pqpk(~kemSk))
    , KeysUsed(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, pqpk(~kemSk), None, None, kemSS, pqpk(~kemSk), prefix(rkCK), chainKey, msgKey) ]->
  [ Session(~id, %1, 'R', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, theirEcdhPk, None, None, kemSS, pqpk(~kemSk), prefix(rkCK), nextChainKey)
  , !RootKey(~id, %1, $Me, kemSS, prefix(rkCK))
  , !ChainKey(~id, %1, $Me, chainKey)
  , !MessageKey(~id, %1, $Me, msgKey) ]

// Model of "iMessage PQ3 Symmetric Ratcheting" (receiver view)
rule ReceiveSymmetricRatchet[color=#FF7F50]:
  let dst = <$Them, theirIdPk, $Me, pk(~idKey)>
      msgKey = hkdf(chainKey, 'msg_key')
      nextChainKey = hkdf(chainKey, 'chain_key')
      body = <'msg_sig', ciphertext, msgKeyIndicator, theirEcdhPk, %i %+ %1, dst, None, None, None>
  in
  [ !IdentityKey($Me, ~idKey)
  , Session(~id, %i, 'R', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, theirEcdhPk, maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, rootKey, chainKey)
  , In(<ciphertext, signature, theirEcdhPk, %i %+ %1, msgKeyIndicator, None, None, None>) ]
  --[ PrePQAttack()
    , Neq(theirEcdhPk, DH_neutral)
    , Neq(theirEcdhPk, 'g')
    , Eq(msgKeyIndicator, hkdf(msgKey, 'msg_key_ind'))
    , Eq(verify(signature, body, theirIdPk), true)
    , SessionInfo(~id, %i %+ %1, $Me, $Them)
    , MessageReceived(~id, %i %+ %1, $Them, $Me, sdec(ciphertext, msgKey))
    , SessionSecrets('g'^~ecdhSk, theirEcdhPk, kemSS, encapPk, chainKey, msgKey)
    , SymmetricRatchet()
    , KeysUsed(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, theirEcdhPk^~ecdhSk, pqpk(~kemSk), maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, rootKey, chainKey, msgKey) ]->
  [ Session(~id, %i %+ %1, 'R', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, theirEcdhPk, maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, rootKey, nextChainKey)
  , !ChainKey(~id, %i %+ %1, $Me, chainKey)
  , !MessageKey(~id, %i %+ %1, $Me, msgKey) ]

// Direction change / public key ratchet

// Non-deterministically decide whether to generate and include a new KEM SK as
// sender.
// Branch 1: Sample and send new KEM SK.
rule SomeFreshKemSk[color=#6495ED]:
  [ Fr(~newKemSk) ]
  --[ PrePQAttack() ]->
  [ NewKemKey($Me, $Them, Just(~newKemSk), Just(pqpk(~newKemSk)))
  , !KemKey($Me, ~newKemSk) ]

// Branch 2: Do not sample and send new KEM SK.
rule NoFreshKemSk[color=#6495ED]:
  [] --[ PrePQAttack() ]-> [ NewKemKey($Me, $Them, None, None) ]

// This and the next rule perform the public key ratchet as the new sender and
// generate a new KEM SS. They model that participant $Me (in the receiver role)
// now wants to send a message and (via pattern matching) whether during the
// last receiving phase the participant $Me received a new KEM public key from
// their peer ($Them).
// Branch 1: Sample new KEM SS.
rule PublicKeyRatchetNewSenderSomeNewKemSS[color=#B4D9EF]:
  let dst = <$Me, pk(~idKey), $Them, theirIdPk>
      ecdhSS          = theirEcdhPk^~ecdhSk
      kemEncap        = encap(~kemSS, theirKemPk)
      rkCK            = hkdf(hkdf(hkdf(ecdhSS, rootKey), ~kemSS), dst)
      chainKey        = suffix(rkCK)
      msgKey          = hkdf(chainKey, 'msg_key')
      msgKeyIndicator = hkdf(msgKey, 'msg_key_ind')
      nextChainKey    = hkdf(chainKey, 'chain_key')
      ciphertext      = senc(~msg, msgKey)
      body            = <'msg_sig', ciphertext, msgKeyIndicator, 'g'^~ecdhSk, %i %+ %1, dst, maybeMyNewKemPk, Just(kemEncap), None>
      signature       = sign(body, ~idKey)
  in
  [ Fr(~ecdhSk), Fr(~kemSS), Fr(~msg)
  , !IdentityKey($Me, ~idKey)
  , Session(~id, %i, 'R', $Me, discard0 /* ~ecdhSk */, ~oldKemSk, $Them, theirIdPk, theirEcdhPk, discard1 /* maybeTheirKemPk */, Just(theirKemPk), discard2 /* oldKemSS */, discard3 /* encapPk */, rootKey, discard4 /* chainKey */)
  , NewKemKey($Me, $Them, maybeNewKemSk, maybeMyNewKemPk) ]
  --[ PrePQAttack()
    , SessionInfo(~id, %i %+ %1, $Me, $Them)
    , PublicKeyRatchet(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, default(maybeMyNewKemPk, pqpk(~oldKemSk)), Just(theirKemPk), None, ~kemSS, theirKemPk, prefix(rkCK))
    , PKRatchet()
    , ToSender()
    , MessageSent(~id, %i %+ %1, $Me, $Them, ~msg)
    , SessionSecrets('g'^~ecdhSk, theirEcdhPk, ~kemSS, theirKemPk, chainKey, msgKey)
    , KeysUsed(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, default(maybeMyNewKemPk, pqpk(~oldKemSk)), Just(theirKemPk), None, ~kemSS, theirKemPk, prefix(rkCK), chainKey, msgKey)
    , ECDHKeyGen(~id, $Me, $Them, 'g'^~ecdhSk)
    , KemKeyGen(~id, $Me, $Them, maybeMyNewKemPk)
    , NewKemSS(~id, $Me, $Them, ~kemSS, theirKemPk)
    , PublicKeyRatchetNewSender(~id, %i %+ %1, $Me, $Them, rkCK) ]->
  // The symmetric ratchet rule will send the message
  [ Out(<ciphertext, signature, 'g'^~ecdhSk, %i %+ %1, msgKeyIndicator, maybeMyNewKemPk, Just(kemEncap), None /* maybePreKeyHash */>)
  , Session(~id, %i %+ %1, 'S', $Me, ~ecdhSk, default(maybeNewKemSk, ~oldKemSk), $Them, theirIdPk, theirEcdhPk, Just(theirKemPk), None /* maybeTheirNewKemPk */, ~kemSS, theirKemPk /* encapPk */, prefix(rkCK), nextChainKey)
  , Out('g'^~ecdhSk)
  , !NonPQSecKey(~ecdhSk)
  , !RootKey(~id, %i %+ %1, $Me, ~kemSS, prefix(rkCK))
  , !ChainKey(~id, %i %+ %1, $Me, chainKey)
  , !MessageKey(~id, %i %+ %1, $Me, msgKey)
  , !ECDHKey(~id, $Me, ~ecdhSk) ]

// Branch 2: Do not sample new KEM SS.
rule PublicKeyRatchetNewSenderNoNewKemSS[color=#B4D9EF]:
  let dst = <$Me, pk(~idKey), $Them, theirIdPk>
      ecdhSS          = theirEcdhPk^~ecdhSk
      rkCK            = hkdf(hkdf(hkdf(ecdhSS, rootKey), '0'), dst)
      chainKey        = suffix(rkCK)
      msgKey          = hkdf(chainKey, 'msg_key')
      msgKeyIndicator = hkdf(msgKey, 'msg_key_ind')
      nextChainKey    = hkdf(chainKey, 'chain_key')
      ciphertext      = senc(~msg, msgKey)
      body            = <'msg_sig', ciphertext, msgKeyIndicator, 'g'^~ecdhSk, %i %+ %1, dst, maybeMyNewKemPk, None /* maybeKemEncap */, None>
      signature       = sign(body, ~idKey)
  in
  [ Fr(~ecdhSk), Fr(~msg)
  , !IdentityKey($Me, ~idKey)
  , Session(~id, %i, 'R', $Me, discard0 /* ~ecdhSk */, ~oldKemSk, $Them, theirIdPk, theirEcdhPk, maybeTheirKemPk, None /* maybeTheirNewKemPk */, kemSS, encapPk, rootKey, discard1 /* chainKey */)
  , NewKemKey($Me, $Them, maybeNewKemSk, maybeMyNewKemPk) ]
  --[ PrePQAttack()
    , SessionInfo(~id, %i %+ %1, $Me, $Them)
    , PublicKeyRatchet(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, default(maybeMyNewKemPk, pqpk(~oldKemSk)), maybeTheirKemPk, None, kemSS, encapPk, prefix(rkCK))
    , PKRatchet()
    , ToSender()
    , MessageSent(~id, %i %+ %1, $Me, $Them, ~msg)
    , SessionSecrets('g'^~ecdhSk, theirEcdhPk, kemSS, encapPk, chainKey, msgKey)
    , KeysUsed(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, default(maybeMyNewKemPk, pqpk(~oldKemSk)), maybeTheirKemPk, None, kemSS, encapPk, prefix(rkCK), chainKey, msgKey)
    , ECDHKeyGen(~id, $Me, $Them, 'g'^~ecdhSk)
    , KemKeyGen(~id, $Me, $Them, maybeMyNewKemPk)
    , PublicKeyRatchetNewSender(~id, %i %+ %1, $Me, $Them, rkCK) ]->
  // The symmetric ratchet rule will send the message
  [ Out(<ciphertext, signature, 'g'^~ecdhSk, %i %+ %1, msgKeyIndicator, maybeMyNewKemPk, None /* maybeKemEncap */, None /* maybePreKeyHash */>)
  , Session(~id, %i %+ %1, 'S', $Me, ~ecdhSk, default(maybeNewKemSk, ~oldKemSk), $Them, theirIdPk, theirEcdhPk, maybeTheirKemPk, None /* maybeTheirNewKemPk */, kemSS, encapPk, prefix(rkCK), nextChainKey)
  , Out('g'^~ecdhSk)
  , !NonPQSecKey(~ecdhSk)
  , !RootKey(~id, %i %+ %1, $Me, kemSS, prefix(rkCK))
  , !ChainKey(~id, %i %+ %1, $Me, chainKey)
  , !MessageKey(~id, %i %+ %1, $Me, msgKey)
  , !ECDHKey(~id, $Me, ~ecdhSk) ]

// This and the next two rules model that participant $Me (in the sender role)
// receives a message, which indicates to them that directions changed and makes
// them perform the public key ratchet.
// Branch 1: No new KEM SS.
rule PublicKeyRatchetNewReceiverNoNewKemSS[color=#B4D9EF]:
  let dst = <$Them, theirIdPk, $Me, pk(~idKey)>
      ecdhSS = theirEcdhPk^~ecdhSk
      rkCK = hkdf(hkdf(hkdf(ecdhSS, rootKey), '0'), dst)
      chainKey = suffix(rkCK)
      msgKey = hkdf(chainKey, 'msg_key')
      nextChainKey = hkdf(chainKey, 'chain_key')
      body = <'msg_sig', ciphertext, msgKeyIndicator, theirEcdhPk, %i %+ %1, dst, maybeTheirNewKemPk, None, None>
  in
  [ !IdentityKey($Me, ~idKey)
  , Session(~id, %i, 'S', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, discard1 /* theirEcdhPk */, maybeTheirKemPk, None /* maybeTheirNewKemPk */, kemSS, encapPk, rootKey, discard2 /* chainKey */)
  , In(<ciphertext, signature, theirEcdhPk, %i %+ %1, msgKeyIndicator, maybeTheirNewKemPk, None /* maybeKemSS */, None /* maybePreKeyHash */>) ]
  --[ PrePQAttack()
    , Neq(theirEcdhPk, DH_neutral)
    , Neq(theirEcdhPk, 'g')
    , Eq(verify(signature, body, theirIdPk), true)
    , Eq(msgKeyIndicator, hkdf(msgKey, 'msg_key_ind'))
    , SessionInfo(~id, %i %+ %1, $Me, $Them)
    , PublicKeyRatchet(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, pqpk(~kemSk), maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, prefix(rkCK))
    , PKRatchet()
    , ToReceiver()
    , NewKemPublicKey(~id, $Me, $Them, maybeTheirNewKemPk)
    , MessageReceived(~id, %i %+ %1, $Them, $Me, sdec(ciphertext, msgKey))
    , SessionSecrets('g'^~ecdhSk, theirEcdhPk, kemSS, encapPk, chainKey, msgKey)
    , KeysUsed(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, pqpk(~kemSk), maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, prefix(rkCK), chainKey, msgKey)
    , PublicKeyRatchetNewReceiver(~id, %i %+ %1, $Them, $Me, rkCK) ]->
  [ Session(~id, %i %+ %1, 'R', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, theirEcdhPk, maybeTheirKemPk, maybeTheirNewKemPk, kemSS, encapPk, prefix(rkCK), nextChainKey)
  , !RootKey(~id, %i %+ %1, $Me, kemSS, prefix(rkCK))
  , !ChainKey(~id, %i %+ %1, $Me, chainKey)
  , !MessageKey(~id, %i %+ %1, $Me, msgKey) ]

rule PublicKeyRatchetNewReceiverWithSomeNewKemSS[color=#B4D9EF]:
  let dst = <$Them, theirIdPk, $Me, pk(~idKey)>
      ecdhSS = theirEcdhPk^~ecdhSk
      decap = decap(kemEncap, ~kemSk)
      rkCK = hkdf(hkdf(hkdf(ecdhSS, rootKey), decap), dst)
      chainKey = suffix(rkCK)
      msgKey = hkdf(chainKey, 'msg_key')
      nextChainKey = hkdf(chainKey, 'chain_key')
      body = <'msg_sig', ciphertext, msgKeyIndicator, theirEcdhPk, %i %+ %1, dst, maybeTheirNewKemPk, Just(kemEncap), None>
  in
  [ !IdentityKey($Me, ~idKey)
  , Session(~id, %i, 'S', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, discard1 /* theirEcdhPk */, maybeTheirKemPk, None /* maybeTheirNewKemPk */, discard2 /* oldKemSS */, discard3 /* encapPk */, rootKey, discard4 /* chainKey */)
  , In(<ciphertext, signature, theirEcdhPk, %i %+ %1, msgKeyIndicator, maybeTheirNewKemPk, Just(kemEncap), None>) ]
  --[ PrePQAttack()
    , Neq(theirEcdhPk, DH_neutral)
    , Neq(theirEcdhPk, 'g')
    , Neq(decap, '0')
    , Eq(verify(signature, body, theirIdPk), true)
    , Eq(msgKeyIndicator, hkdf(msgKey, 'msg_key_ind'))
    , SessionInfo(~id, %i %+ %1, $Me, $Them)
    , PublicKeyRatchet(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, pqpk(~kemSk), maybeTheirKemPk, maybeTheirNewKemPk, decap, pqpk(~kemSk), prefix(rkCK))
    , PKRatchet()
    , ToReceiver()
    , NewKemPublicKey(~id, $Me, $Them, maybeTheirNewKemPk)
    , MessageReceived(~id, %i %+ %1, $Them, $Me, sdec(ciphertext, msgKey))
    , SessionSecrets('g'^~ecdhSk, theirEcdhPk, decap, pqpk(~kemSk), chainKey, msgKey)
    , KeysUsed(theirIdPk, 'g'^~ecdhSk, theirEcdhPk, ecdhSS, pqpk(~kemSk), maybeTheirKemPk, maybeTheirNewKemPk, decap, pqpk(~kemSk), prefix(rkCK), chainKey, msgKey)
    , PublicKeyRatchetNewReceiver(~id, %i %+ %1, $Them, $Me, rkCK)
    , DecapKemSS(~id, $Me, $Them, decap, pqpk(~kemSk)) ]->
  [ Session(~id, %i %+ %1, 'R', $Me, ~ecdhSk, ~kemSk, $Them, theirIdPk, theirEcdhPk, maybeTheirKemPk, maybeTheirNewKemPk, decap, pqpk(~kemSk), prefix(rkCK), nextChainKey)
  , !RootKey(~id, %i %+ %1, $Me, decap, prefix(rkCK))
  , !ChainKey(~id, %i %+ %1, $Me, chainKey)
  , !MessageKey(~id, %i %+ %1, $Me, msgKey) ]

// Provable (manually). When solving for the first signature (following the
// oracle), continue in case PublicKeyRatchetNewSenderSomeNewKemSS_case_3. Then,
// when almost at the end, make sure to avoid the loop in the
// SendSymmetricRatchet case.
lemma ExecutabilityPublicKeyRatchetSomeNewKEMSS:
  exists-trace
  "Ex id1 id2 i s r rk m #t1 #t2 #t3.
      PublicKeyRatchetNewReceiver(id2, i, s, r, rk) @ #t3
    & (Ex decap pk. DecapKemSS(id2, s, r, decap, pk) @ #t3)
    & MessageReceived(id2, i, s, r, m) @ #t3
    & PublicKeyRatchetNewSender(id1, i, s, r, rk) @ #t1
    & MessageSent(id1, i, s, r, m) @ #t2
    & (not Ex #x. SomeCompromise() @ #x)"

// Provable (manually). Avoid the loop in the SendSymmetriccRatchet case at the
// very end.
lemma ExecutabilityPublicKeyRatchetNoNewKEMSS:
  exists-trace
  "Ex id1 id2 i s r rk m #t1 #t2 #t3.
      PublicKeyRatchetNewReceiver(id2, i, s, r, rk) @ #t3
    & (not Ex decap pk. DecapKemSS(id2, s, r, decap, pk) @ #t3)
    & MessageReceived(id2, i, s, r, m) @ #t3
    & PublicKeyRatchetNewSender(id1, i, s, r, rk) @ #t1
    & MessageSent(id1, i, s, r, m) @ #t2
    & (not Ex #x. SomeCompromise() @ #x)"

// Provable (auto)
lemma SessionStart[reuse,use_induction]:
  "All id li me them theirIdPk a b c d e f g h i j k #t.
        ( SessionInfo(id, li, me, them) @ #t
        & KeysUsed(theirIdPk, a, b, c, d, e, f, g, h, i, j, k) @ #t)
    ==> (Ex #x. SessionStart(theirIdPk) @ #x
          & SessionInfo(id, %1, me, them) @ #x)"

// Provable (auto)
lemma SessionStartUnique[reuse]:
  "All id a1 a2 b1 b2 #t1 #t2.
        ( SessionInfo(id, %1, a1, b1) @ #t1
        & SessionInfo(id, %1, a2, b2) @ #t2)
    ==> #t1 = #t2"

// Provable (auto)
lemma ECDHSkOrigin[reuse,use_induction]:
  "All id li me them myPk a b c d e f g h i j k #t.
        ( SessionInfo(id, li, me, them) @ #t
        & KeysUsed(a, myPk, b, c, d, e, f, g, h, i, j, k) @ #t)
    ==> ( (Ex #x. ECDHKeyGen(id, me, them, myPk) @ #x & (#x < #t | #x = #t))
        | (Ex #x. ECDHPreKeyGen(me, myPk) @ #x & #x < #t))"

// Provable (auto)
lemma RootKeyConnectionSend[reuse,use_induction]:
  "All id i me them m theirIdPk myPk theirPk maybeNewKemPk ecdhSS myKemPk maybeTheirKemPk kemSS encapPk rk ck mk #t.
        ( MessageSent(id, i, me, them, m) @ #t
        & SymmetricRatchet() @ #t
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, maybeNewKemPk, myKemPk, maybeTheirKemPk, kemSS, encapPk, rk, ck, mk) @ #t)
    ==> (Ex i2 #x.
            SessionInfo(id, i2, me, them) @ #x
          & PublicKeyRatchet(theirIdPk, myPk, theirPk, ecdhSS, maybeNewKemPk, myKemPk, maybeTheirKemPk, kemSS, encapPk, rk) @ #x
          & ToSender() @ #x
          & #x < #t
          & i2 << i)"

// Provable (auto)
lemma RootKeyConnectionReceive[reuse,use_induction]:
  "All id i me them m theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t.
        ( MessageReceived(id, i, them, me, m) @ #t
        & SymmetricRatchet() @ #t
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t)
    ==> (Ex i2 #x.
            SessionInfo(id, i2, me, them) @ #x
          & PublicKeyRatchet(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk) @ #x
          & ToReceiver() @ #x
          & #x < #t
          & i2 << i)"

// Provable (auto; tens of minutes)
lemma RootKeyMonotonicity[reuse,use_induction]:
  "All id li1 li2 me1 me2 them1 them2 a1 a2 b1 b2 c1 c2 d1 d2 e1 e2 f1 f2 g1 g2 h1 h2 i1 i2 rk1 rk2 j1 j2 k1 k2 #t1 #t2.
        ( SessionInfo(id, li1, me1, them1) @ #t1
        & KeysUsed(a1, b1, c1, d1, e1, f1, g1, h1, i1, rk1, j1, k1) @ #t1
        & SessionInfo(id, li2, me2, them2) @ #t2
        & KeysUsed(a2, b2, c2, d2, e2, f2, g2, h2, i2, rk2, j2, k2) @ #t2
        & #t1 < #t2)
    ==> (rk1 << rk2 | rk1 = rk2)"

// Provable (auto)
lemma ChainKeyMonotonicity[reuse,use_induction,hide_lemma=SessionStart,hide_lemma=SessionStartUnique,
  hide_lemma=RootKeyConnectionSend,hide_lemma=ECDHSkOrigin,hide_lemma=RootKeyConnectionReceive,
  hide_lemma=RootKeyMonotonicity]:
  "All rkCK ck a b c d e f g h i j #t.
        (KeysUsed(a, b, c, d, e, f, g, h, i, prefix(rkCK), ck, j) @ #t)
    ==> (rkCK << ck)"

// Provable (auto)
lemma RootKeyConnectionInjectivity[reuse,use_induction,hide_lemma=RootKeyConnectionSend,
  hide_lemma=RootKeyConnectionReceive,hide_lemma=ChainKeyMonotonicity]:
  "All id i1 i2 me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk #t1 #t2.
        ( SessionInfo(id, i1, me, them) @ #t1
        & PublicKeyRatchet(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk) @ #t1
        & SessionInfo(id, i2, me, them) @ #t2
        & PublicKeyRatchet(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk) @ #t2)
    ==> (#t1 = #t2)"

// Provable (auto)
lemma MkCkRelation[reuse,use_induction]:
  "All a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2 ck1 ck2 mk #t1 #t2.
        ( KeysUsed(a1, b1, c1, d1, e1, f1, g1, h1, i1, j1, ck1, mk) @ #t1
        & KeysUsed(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, ck2, mk) @ #t2)
    ==> ck1 = ck2"

// Provable (auto)
lemma CkRkRelation[reuse,use_induction]:
  "All a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2 rk1 rk2 ck #t1 #t2.
        ( KeysUsed(a1, b1, c1, d1, e1, f1, g1, h1, i1, rk1, ck, j1) @ #t1
        & KeysUsed(a2, b2, c2, d2, e2, f2, g2, h2, i2, rk2, ck, j2) @ #t2)
    ==> rk1 = rk2"

// Provable (auto)
lemma ECDHSSCompromise[reuse]:
  "All id i me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t1 #t2.
        ( SessionInfo(id, i, me, them) @ #t1
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t1
        & KU(ecdhSS) @ #t2 )
    ==> ( (Ex #x. CompromisedECDHPreKey(them, theirPk) @ #x)
        | (Ex #x. CompromisedECDHKey(id, me, myPk) @ #x)
        | (Ex id2 #x. CompromisedECDHKey(id2, them, theirPk) @ #x)
        | (Ex #x. CompromisedIdentityKey(them) @ #x & #x < #t1)
        | (Ex #x. PQAttack() @ #x))"

// Provable (auto)
lemma MyKemKeyOrigin[reuse,use_induction,hide_lemma=ECDHSSCompromise,
  hide_lemma=SessionStart,hide_lemma=ECDHSkOrigin]:
  "All id i me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t.
        ( SessionInfo(id, i, me, them) @ #t
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t
        & not KemKeyGen(id, me, them, Just(myKemPk)) @ #t)
    ==> ( (Ex #x. KemKeyGen(id, me, them, Just(myKemPk)) @ #x & #x < #t)
        | (Ex #x. KemPreKeyGen(me, myKemPk) @ #x & #x < #t))"

// Provable (auto)
lemma MaybeNewKemKeyOrigin[reuse,use_induction,hide_lemma=ECDHSSCompromise,
  hide_lemma=SessionStart,hide_lemma=ECDHSkOrigin,hide_lemma=MyKemKeyOrigin]:
  "All id i me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk newKemPk kemSS encapPk rk ck mk #t.
        ( SessionInfo(id, i, me, them) @ #t
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, Just(newKemPk), kemSS, encapPk, rk, ck, mk) @ #t
        & not NewKemPublicKey(id, me, them, Just(newKemPk)) @ #t)
    ==> (Ex #x. NewKemPublicKey(id, me, them, Just(newKemPk)) @ #x & #x < #t)"

// Provable (auto)
lemma TheirKemKeyOrigin[reuse,use_induction,hide_lemma=ECDHSSCompromise,
  hide_lemma=SessionStart,hide_lemma=ECDHSkOrigin,hide_lemma=MyKemKeyOrigin]:
  "All id i me them theirIdPk myPk theirPk ecdhSS myKemPk theirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t.
        ( SessionInfo(id, i, me, them) @ #t
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, Just(theirKemPk), maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t
        & not NewKemPublicKey(id, me, them, Just(theirKemPk)) @ #t)
    ==> (Ex #x. NewKemPublicKey(id, me, them, Just(theirKemPk)) @ #x & #x < #t)"

// Provable (auto)
lemma KemSSOrigin[reuse,use_induction,hide_lemma=ECDHSSCompromise,
  hide_lemma=SessionStart,hide_lemma=ECDHSkOrigin,hide_lemma=MyKemKeyOrigin,
  hide_lemma=MaybeNewKemKeyOrigin,hide_lemma=TheirKemKeyOrigin]:
  "All id i me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t.
        ( SessionInfo(id, i, me, them) @ #t
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t
        & not NewKemSS(id, me, them, kemSS, encapPk) @ #t
        & not DecapKemSS(id, me, them, kemSS, encapPk) @ #t)
    ==> ( (Ex #x. NewKemSS(id, me, them, kemSS, encapPk) @ #x & #x < #t)
        | (Ex #x. DecapKemSS(id, me, them, kemSS, encapPk) @ #x & #x < #t))"

// Provable (auto)
lemma KemKeyOriginEncap[reuse,hide_lemma=ECDHSSCompromise,hide_lemma=SessionStart,
  hide_lemma=ECDHSkOrigin,hide_lemma=KemSSOrigin]:
  "All id i me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t.
        ( SessionInfo(id, i, me, them) @ #t
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t
        & NewKemSS(id, me, them, kemSS, encapPk) @ #t
        & not NewKemPublicKey(id, me, them, Just(encapPk)) @ #t)
    ==> (Ex #x. NewKemPublicKey(id, me, them, Just(encapPk)) @ #x & #x < #t)"

// Provable (auto)
lemma KemKeyOriginDecap[reuse,hide_lemma=ECDHSSCompromise,hide_lemma=SessionStart,
  hide_lemma=ECDHSkOrigin,hide_lemma=KemSSOrigin]:
  "All id i me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t.
        ( SessionInfo(id, i, me, them) @ #t
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t
        & DecapKemSS(id, me, them, kemSS, encapPk) @ #t)
    ==> ( (Ex #x. KemKeyGen(id, me, them, Just(encapPk)) @ #x & #x < #t)
        | (Ex #x. KemPreKeyGen(me, encapPk) @ #x & #x < #t))"

// Provable (manually). One must instantiate the PublicKeyRatchet facts manually
// in branches related to the session start and symmetric ratchet. In these
// branches, first solve for a public key ratchet and then for the Session fact
// in the premise of the new public key ratchet step.
lemma RkFixesKEMSS[reuse,use_induction,hide_lemma=ECDHSSCompromise,
  hide_lemma=SessionStart,hide_lemma=ECDHSkOrigin]:
  "All rk kemSS1 kemSS2 a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 a2 b2 c2 d2 e2 f2 g2 h2 i2
    j2 id1 li1 me1 them1 id2 li2 me2 them2 #t1 #t2.
        ( SessionInfo(id1, li1, me1, them1) @ #t1
        & KeysUsed(a1, b1, c1, d1, e1, f1, g1, kemSS1, h1, rk, i1, j1) @ #t1
        & SessionInfo(id2, li2, me2, them2) @ #t2
        & KeysUsed(a2, b2, c2, d2, e2, f2, g2, kemSS2, h2, rk, i2, j2) @ #t2)
    ==> (kemSS1 = kemSS2)"

// Provable (auto)
lemma RkFixesEcdhSS[reuse,use_induction,hide_lemma=MyKemKeyOrigin,hide_lemma=MaybeNewKemKeyOrigin,
  hide_lemma=TheirKemKeyOrigin,hide_lemma=KemSSOrigin,hide_lemma=KemKeyOriginEncap,
  hide_lemma=KemKeyOriginDecap,hide_lemma=RkFixesKEMSS]:
  "All rk ecdhSS1 ecdhSS2 a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 a2 b2 c2 d2 e2 f2 g2 h2 i2
    j2 id1 li1 me1 them1 id2 li2 me2 them2 #t1 #t2.
        ( SessionInfo(id1, li1, me1, them1) @ #t1
        & KeysUsed(a1, b1, c1, ecdhSS1, d1, e1, f1, g1, h1, rk, i1, j1) @ #t1
        & SessionInfo(id2, li2, me2, them2) @ #t2
        & KeysUsed(a2, b2, c2, ecdhSS2, d2, e2, f2, g2, h2, rk, i2, j2) @ #t2)
    ==> (ecdhSS1 = ecdhSS2)"

// Provable (manually). Sometimes, the oracle does not pick out the right
// signatures to solve for, and we cannot prioritize the application of the
// lemma KemKeyOriginDecap as this can lead to infinite looping, i.e., must be
// done manually. This is especially prevalent in branches where one must solve
// for DecapKemSS.
lemma KemSSCompromise[reuse,hide_lemma=ECDHSSCompromise,hide_lemma=ECDHSkOrigin,
  hide_lemma=MyKemKeyOrigin,hide_lemma=MaybeNewKemKeyOrigin,hide_lemma=TheirKemKeyOrigin]:
  "All id i me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t1 #t2.
        ( SessionInfo(id, i, me, them) @ #t1
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t1
        & KU(kemSS) @ #t2)
    ==> ( (Ex #x. CompromisedKemKey(me, encapPk) @ #x)
        | (Ex #x. CompromisedKemKey(them, encapPk) @ #x)
        | (Ex #x. CompromisedKemPreKey(me, encapPk) @ #x)
        | (Ex #x. CompromisedKemPreKey(them, encapPk) @ #x)
        | (Ex #x. CompromisedIdentityKey(them) @ #x & #x < #t1))"

// Provable (manually). Be careful in cases of the symmetric ratchet.
lemma CkCompromise[reuse,use_induction,hide_lemma=ECDHSkOrigin,hide_lemma=MyKemKeyOrigin,
  hide_lemma=MaybeNewKemKeyOrigin,hide_lemma=TheirKemKeyOrigin,hide_lemma=KemKeyOrigin,
  hide_lemma=KemSSOrigin]:
  "All id li me them theirIdPk myPk theirPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rk ck mk #t1 #t2.
        ( SessionInfo(id, li, me, them) @ #t1
        & KeysUsed(theirIdPk, myPk, theirPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, rk, ck, mk) @ #t1
        & KU(ck) @ #t2)
    ==> ( (Ex ckC #x. CompromisedChainKey(me, ckC) @ #x
            & (ckC << ck | ckC = ck))
        | (Ex ckC #x. CompromisedChainKey(them, ckC) @ #x
            & (ckC << ck | ckC = ck))
        | (Ex rkCK #x. rk = prefix(rkCK) & !KU(rkCK) @ #x))"

// Provable (auto)
lemma RkFormat[reuse,use_induction]:
  "All rk a b c d e f g h i k l #t.
        KeysUsed(a, b, c, d, e, f, g, h, i, rk, k, l) @ #t
    ==> Ex t. rk = prefix(t)"

// Provable (auto)
lemma RkSecretCompromiseECDH[reuse,hide_lemma=CkCompromise,hide_lemma=SessionStart,
  hide_lemma=ECDHSkOrigin,hide_lemma=MyKemKeyOrigin,hide_lemma=MaybeNewKemKeyOrigin,
  hide_lemma=TheirKemKeyOrigin,hide_lemma=KemSSOrigin,hide_lemma=KemKeyOriginEncap,
  hide_lemma=KemKeyOriginDecap,hide_lemma=KemSSCompromise]:
  "All id li me them theirIdPk myEcdhPk theirEcdhPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rkCK ck mk #t1 #t2.
        ( SessionInfo(id, li, me, them) @ #t1
        & KeysUsed(theirIdPk, myEcdhPk, theirEcdhPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, prefix(rkCK), ck, mk) @ #t1
        & KU(rkCK) @ #t2)
    ==> ( (Ex #x. CompromisedChainKey(me, suffix(rkCK)) @ #x)
        | (Ex #x. CompromisedChainKey(them, suffix(rkCK)) @ #x)
        | (Ex #x. !KU(ecdhSS) @ #x))"

// Provable (auto)
lemma RkSecretCompromiseKemSS[reuse,use_induction,hide_lemma=SessionStart,hide_lemma=SessionStartUnique,
  hide_lemma=ECDHSkOrigin,hide_lemma=ECDHSSCompromise,hide_lemma=MyKemKeyOrigin,
  hide_lemma=MaybeNewKemKeyOrigin,hide_lemma=TheirKemKeyOrigin,hide_lemma=KemSSOrigin,
  hide_lemma=KemKeyOriginEncap,hide_lemma=KemKeyOriginDecap,hide_lemma=RkFixesEcdhSS,
  hide_lemma=CkCompromise,hide_lemma=RkSecretCompromiseECDH]:
  "All id li me them theirIdPk myEcdhPk theirEcdhPk ecdhSS myKemPk maybeTheirKemPk maybeNewKemPk kemSS encapPk rkCK ck mk #t1 #t2.
        ( SessionInfo(id, li, me, them) @ #t1
        & KeysUsed(theirIdPk, myEcdhPk, theirEcdhPk, ecdhSS, myKemPk, maybeTheirKemPk, maybeNewKemPk, kemSS, encapPk, prefix(rkCK), ck, mk) @ #t1
        & KU(rkCK) @ #t2)
    ==> ( (Ex #x. !KU(kemSS) @ #x)
        | (Ex rk #x. CompromisedRootKey(me, kemSS, rk) @ #x)
        | (Ex rk #x. CompromisedRootKey(them, kemSS, rk) @ #x))"

// Provable (auto)
// NOTE: This lemma is very close the ChainKeyMonotonicity, but I need this form
// for CkCompromiseFull. I decided to add it here instead of changing the
// original one so that I don't need to reprove everything above.
lemma ChainKeyMonotonicity2[reuse,use_induction,hide_lemma=SessionStart,hide_lemma=SessionStartUnique,
  hide_lemma=RootKeyConnectionSend,hide_lemma=ECDHSkOrigin,hide_lemma=RootKeyConnectionReceive,
  hide_lemma=RootKeyMonotonicity]:
  "All rkCK ck a b c d e f g h i j #t.
        (KeysUsed(a, b, c, d, e, f, g, h, i, prefix(rkCK), ck, j) @ #t)
    ==> (suffix(rkCK) << ck | suffix(rkCK) = ck)"

// Provable (auto)
lemma MkCompromise[reuse,use_induction,hide_lemma=SessionStart,hide_lemma=SessionStartUnique,
  hide_lemma=ECDHSkOrigin,hide_lemma=RootKeyConnectionSend,hide_lemma=RootKeyConnectionReceive,
  hide_lemma=ECDHSSCompromise,hide_lemma=MyKemKeyOrigin,hide_lemma=MaybeNewKemKeyOrigin,
  hide_lemma=TheirKemKeyOrigin,hide_lemma=KemSSOrigin,hide_lemma=KemKeyOriginEncap,
  hide_lemma=KemKeyOriginDecap,hide_lemma=KemSSCompromise,hide_lemma=CkCompromise,
  hide_lemma=RkSecretCompromiseECDH,hide_lemma=RkSecretCompromiseKemSS]:
  "All id sentI me them myEcdhPk theirEcdhPk kemSS encapPk chainKey msgKey #t1 #t2.
        ( SessionInfo(id, sentI, me, them) @ #t1
        & SessionSecrets(myEcdhPk, theirEcdhPk, kemSS, encapPk, chainKey, msgKey) @ #t1
        & !KU(msgKey) @ #t2)
    ==> ( (Ex #x. !KU(chainKey) @ #x)
        | (Ex #x. CompromisedMessageKey(me, msgKey) @ #x)
        | (Ex #x. CompromisedMessageKey(them, msgKey) @ #x))"

// Provable (auto)
lemma Secrecy[hide_lemma=SessionStart,hide_lemma=SessionStartUnique,hide_lemma=ECDHSkOrigin,
  hide_lemma=RootKeyConnectionSend,hide_lemma=RootKeyConnectionReceive,hide_lemma=MyKemKeyOrigin,
  hide_lemma=MaybeNewKemKeyOrigin,hide_lemma=TheirKemKeyOrigin,hide_lemma=KemSSOrigin,
  hide_lemma=KemKeyOriginEncap,hide_lemma=KemKeyOriginDecap]:
  "All id sentI me them msg myEcdhPk theirEcdhPk kemSS encapPk chainKey msgKey #t.
          // Whenever a message is sent...
        ( MessageSent(id, sentI, me, them, msg) @ #t
        & SessionSecrets(myEcdhPk, theirEcdhPk, kemSS, encapPk, chainKey, msgKey) @ #t)
          // ...it remains confidential...
    ==>   (not Ex #x. K(msg) @ #x)
        | (Ex #x. CompromisedMessageKey(me, msgKey) @ #x)
        | (Ex #x. CompromisedMessageKey(them, msgKey) @ #x)
        | (Ex ckC #x. CompromisedChainKey(me, ckC) @ #x
            & (ckC << chainKey | ckC = chainKey))
        | (Ex ckC #x. CompromisedChainKey(them, ckC) @ #x
            & (ckC << chainKey | ckC = chainKey))
          // ...OR one of the long-term identity keys were compromised
        | (Ex #x. CompromisedIdentityKey(them) @ #x & #x < #t)
          // ...OR one ECDH key AND the KEM SS was compromised
        | ( ( (Ex #x. PQAttack() @ #x)
              // One ECDH key was compromised means that either the peer's ECDH
              // pre-key was compromised...
            | (Ex #x. CompromisedECDHPreKey(them, theirEcdhPk) @ #x)
              // ...OR one of the ECDH keys that were used in the latest public key
              // ratchet was compromised.
            | (Ex #x. CompromisedECDHKey(id, me, myEcdhPk) @ #x)
            | (Ex id2 #x. CompromisedECDHKey(id2, them, theirEcdhPk) @ #x))
          & // The KEM SS being compromised means that the recently used KEM
            // encapsulation key was compromised...
            ( (Ex #x. CompromisedKemKey(me, encapPk) @ #x)
            | (Ex #x. CompromisedKemKey(them, encapPk) @ #x)
              // ...OR the initial recipient's KEM pre key was compromised.
            | (Ex #x. CompromisedKemPreKey(me, encapPk) @ #x)
            | (Ex #x. CompromisedKemPreKey(them, encapPk) @ #x)
            | (Ex rk #x. CompromisedRootKey(me, kemSS, rk) @ #x)
            | (Ex rk #x. CompromisedRootKey(them, kemSS, rk) @ #x)))"

/* AUTHENTICATION BELOW */

// Provable (auto)
lemma NoninjectiveAuthentication [hide_lemma=SessionStartUnique,hide_lemma=ECDHSkOrigin,
  hide_lemma=RootKeyConnectionSend,hide_lemma=RootKeyConnectionReceive,hide_lemma=RootKeyMonotonicity,
  hide_lemma=ChainKeyMonotonicity,hide_lemma=RootKeyConnectionInjectivity,hide_lemma=MkCkRelation,
  hide_lemma=CkRkRelation,hide_lemma=ECDHSSCompromise,hide_lemma=MyKemKeyOrigin,
  hide_lemma=MaybeNewKemKeyOrigin,hide_lemma=TheirKemKeyOrigin,hide_lemma=KemSSOrigin,
  hide_lemma=KemKeyOriginEncap,hide_lemma=KemKeyOriginDecap,hide_lemma=KemSSCompromise,
  hide_lemma=CkCompromise,hide_lemma=Secrecy,hide_lemma=RkFixesKEMSS,hide_lemma=RkFixesEcdhSS,
  hide_lemma=RkFormat,hide_lemma=RkSecretCompromiseECDH,hide_lemma=RkSecretCompromiseKemSS,
  hide_lemma=ChainKeyMonotonicity2,hide_lemma=MkCompromise]:
  "All id i s r m #t.
        MessageReceived(id, i, s, r, m) @ #t
    ==>   (Ex id_ #x. MessageSent(id_, i, s, r, m) @ #x & #x < #t)
        | (Ex #x. CompromisedIdentityKey(s) @ #x & #x < #t)"

// Provable (auto)
lemma InjectiveMessageReceived[hide_lemma=ECDHSSCompromise,
  hide_lemma=MyKemKeyOrigin,hide_lemma=MaybeNewKemKeyOrigin,hide_lemma=TheirKemKeyOrigin,
  hide_lemma=KemSSOrigin,hide_lemma=KemKeyOriginEncap,hide_lemma=KemKeyOriginDecap,
  hide_lemma=KemSSCompromise,hide_lemma=CkCompromise,hide_lemma=Secrecy,hide_lemma=RkFixesKEMSS,hide_lemma=RkFixesEcdhSS,
  hide_lemma=RkFormat,hide_lemma=RkSecretCompromiseECDH,hide_lemma=RkSecretCompromiseKemSS,
  hide_lemma=ChainKeyMonotonicity2,hide_lemma=MkCompromise]:
  "All id1 id2 i1 i2 s1 s2 r1 r2 m rEcdhPk1 sEcdhPk1 kemSS1 encapPk1 chainKey1
      msgKey1 rEcdhPk2 sEcdhPk2 kemSS2 encapPk2 chainKey2 msgKey2 #t1 #t2.
        ( MessageReceived(id1, i1, s1, r1, m) @ #t1
        & SessionSecrets(rEcdhPk1, sEcdhPk1, kemSS1, encapPk1, chainKey1, msgKey1) @ #t1
        & MessageReceived(id2, i2, s2, r2, m) @ #t2
        & SessionSecrets(rEcdhPk2, sEcdhPk2, kemSS2, encapPk2, chainKey2, msgKey2) @ #t2)
    ==> ( (#t1 = #t2)
        | (rEcdhPk1 = rEcdhPk2 & msgKey1 = msgKey2 & s1 = s2 & r1 = r2 & Ex #x. ECDHPreKeyGen(r1, rEcdhPk1) @ #x)
        | (Ex #x. CompromisedIdentityKey(s1) @ #x & #x < #t1)
        | (Ex #x. CompromisedIdentityKey(s2) @ #x & #x < #t2))"

end
